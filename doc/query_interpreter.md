# Query Interpreter

## Overview

The Query Interpreter allows to interpret LLVM IR generated by codegen instead of compiling it. 

## Scope
* all files are in the namespace peloton::codegen::interpreter
* codegen::Query can decide whether to compile and run the query or to interpret it. 

## Glossary (Optional)
RPO
 : Reverse Post Order - a way to traverse the control flow graph, needed for linear scanning register allocation
IP
 : Instruction Pointer - refers to the interpreter IP (not the actual IP of the processor)

## Architectural Design
>Explain the input and output of the component, describe interactions and breakdown the smaller components if any. Include diagrams if appropriate.

### interpreter::InterpreterContext
Holds all information, that is required to interpret a query, and is completely independent from the CodeContext it was created from (except for the tracing information in Debug mode). Once created, it can be executed many times. However, it is not supposed to be saved, but rather to be created on-the-fly before execution. 

This consists of:

* the bytecode itself
* information needed to create the activation record:
  * number of value slots to create
  * where function arguments go to
  * which constants to initialize
  * call contexts for external function calls
* contexts for internal function calls
* in Debug mode: tracing information

All references in the interpreter context are done with indexes: 
* values are referenced with indexes for the value slots
* instructions are referenced with indexes for the instruction stream

### interpreter::ContextBuilder
Creates a InterpreterContext object from a LLVM function inside a CodeContext, that can be handed to the QueryInterpreter. 

`interpreter::InterpreterContext context = interpreter::ContextBuilder::CreateInterpreterContext(code_context_, query_funcs_.plan_func);`

If the LLVM function can not be translated (because of missing features/types) a NotSupportedException is thrown. (Currently all queries should be supported)

The ContextBuilder works in 4 steps:

1. Analysis
2. Register Allocation
3. Translation
4. Finalization

Internal the ContextBuilder assigns indexes to LLVM values and instructions, which are usually only accessed by raw pointers. They are used to merge several LLVM values and to compute liveliness. 
Those indexes stay inside the ContextBuilder and do not end up in the InterpreterContext. They are completely independent from the indexes in the InterpreterContext! 

#### 1. Analysis
Analysis the LLVM function and creates additional information, but doesn't create bytecode. 

* determining liveliness of all LLVM values (definition and last usage)
  * linear scan algorithm using reverse post order traversal of basic blocks
  * the scheduling of the basic blocks is determined by the reverse post order traversal to make this work
* merges LLVM values that are equivalent, e.g. when LLVM instructions translate to NOPs
* merges LLVM constants, which have the same value

#### 2. Register Allocation
Global register allocation: maps every LLVM Value in the LLVM function to a value slot (register). 

Two register allocation alrogithms are available:

1. naive: every LLVM Value is assigned to a unique value slot (SSA characteristic)
2. greedy: for each value find the next value slot, that is not occupied anymore (or create a new one if necessary)

#### 3. Translation
Translates every LLVM instruction into a bytecode instruction (if not NOP) and places it in the bytecode stream.

As the translation is done in one pass and the instructions can have different size, the destination instruction index for branch instructions is not known when creating the instruction. Therefore these relocations are saved and applied at the end of the pass, when all indexes are known. 

At the end of each basic block, mov instructions are created to resolve the Phi's referencing the basic block. 

Because of the Phi swap problem (lost copy) it can happen, that during translation additional value slots are needed that have not been mapped by the register allocation. The number of additional temporary value slots is tracked and added to the overall number of value slots during finalization. 

#### 4. Finalization
Calculate overall number of required value slots (including the temporary ones added in the translation pass) and prepare the data structures in the interpreter context for creating the activation record. 


### interpreter::QueryInterpreter
Takes a interpreter context and executes the function it was created for by interpreting the bytecode. 

`return_value = interpreter::QueryInterpreter::ExecuteFunction(context, {args, ...});`

For every invocation of a function, a new activation record is created, so recursive calls are actually possible. 

## Design Rationale
>Explain the goals of this design and how the design achieves these goals. Present alternatives considered and document why they are not chosen.



## Testing Plan
>How should the component be tested?



## Trade-offs and Potential Problems
>Write down any conscious trade-off you made that can be problematic in the future, or any problems discovered during the design process that remain unaddressed (technical debts).

* not complete LLVM IR instruction coverage
  * LLVM vector types are not supported
* LLVM values are restricted to max. 8 byte
  * usually not a problem, except we start introducing SIMD inside codegen

*But* every query that is currently created by our test cases is supported. 

## Future Work
>Write down future work to fix known problems or otherwise improve the component.


