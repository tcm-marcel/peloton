<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/home/marcel/dev/scripts/docs/github-pandoc.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#query-interpreter">Query Interpreter</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#scope">Scope</a></li>
<li><a href="#glossary-optional">Glossary (Optional)</a></li>
<li><a href="#architectural-design">Architectural Design</a><ul>
<li><a href="#interpreterinterpretercontext">interpreter::InterpreterContext</a></li>
<li><a href="#interpretercontextbuilder">interpreter::ContextBuilder</a></li>
<li><a href="#interpreterqueryinterpreter">interpreter::QueryInterpreter</a></li>
</ul></li>
<li><a href="#testing-plan">Testing Plan</a></li>
<li><a href="#trade-offs-and-potential-problems">Trade-offs and Potential Problems</a></li>
<li><a href="#future-work">Future Work</a></li>
</ul></li>
</ul>
</nav>
<h1 id="query-interpreter">Query Interpreter</h1>
<h2 id="overview">Overview</h2>
<p>The Query Interpreter allows to interpret LLVM IR generated by codegen instead of compiling it.</p>
<h2 id="scope">Scope</h2>
<ul>
<li>All files are in the namespace <code>peloton::codegen::interpreter</code></li>
<li><code>codegen::Query</code> can decide whether to compile and run the query or to interpret it.</li>
</ul>
<h2 id="glossary-optional">Glossary (Optional)</h2>
<dl>
<dt>RPO</dt>
<dd>Reverse Post Order - a way to traverse the control flow graph, needed for linear scanning register allocation
</dd>
<dt>IP</dt>
<dd>Instruction Pointer - refers to the interpreter IP (not the actual IP of the processor)
</dd>
</dl>
<h2 id="architectural-design">Architectural Design</h2>
<p>The Query Interpreter consists of three components:</p>
<h3 id="interpreterinterpretercontext">interpreter::InterpreterContext</h3>
<p>Holds all information, that is required to interpret a query, and is completely independent from the CodeContext it was created from (except for the tracing information in Debug mode). Once created, it can be executed many times. However, it is not supposed to be saved, but rather to be created on-the-fly before execution.</p>
<p>This consists of:</p>
<ul>
<li>The bytecode itself</li>
<li>Information needed to create the activation record:
<ul>
<li>Number of value slots to create</li>
<li>Where function arguments go to</li>
<li>Which constants to initialize</li>
<li>Call contexts for external function calls</li>
</ul></li>
<li>Contexts for internal function calls</li>
<li>In Debug mode: tracing information</li>
</ul>
<p>All references in the interpreter context are done with indexes:</p>
<ul>
<li>Values are referenced with indexes for the value slots</li>
<li>Instructions are referenced with indexes for the instruction stream</li>
</ul>
<h4 id="bytecode-internals">Bytecode Internals</h4>
<p>All bytecode instructions are defined in <code>bytecode_definitions.def</code>. Most instructions are typed and get automatically expanded to their type instances. Typed instructions are accessed by there suffix <code>&lt;opcode_untyped&gt;_&lt;type&gt;</code>, e.g. <code>add_i8</code>. Type expansion is supported for integer types, floating point types and both.</p>
<p>Most instructions follow the pattern of having a 2 byte opcode and several 2 byte arguments. Instructions usually fit in a single instruction slot, some instructions however require two or more instruction slots.</p>
<p><em>There is no documentation about the structure of all bytecode instructions. To find out about the arguments of a bytecode instruction, find the corresponding translate function in the ContextBuilder and the handler in the QueryCompiler. </em></p>
<p>The 2 byte arguments in the bytecode instructions can be one of the following:</p>
<ol type="1">
<li>A value slot index (most arguments in most instructions)</li>
<li>A instruction slot index (for branch instruction)</li>
<li>An immediate value (only for alloca, gep_offset and extractvalue)</li>
</ol>
<p>Value Slot zero is a dummy slot. It is used for unused values that have to be put somewhere. This way we avoid handling the cases where wo do not want to use a value.</p>
<h3 id="interpretercontextbuilder">interpreter::ContextBuilder</h3>
<p>Creates a InterpreterContext object from a LLVM function inside a CodeContext, that can be handed to the QueryInterpreter.</p>
<p><code>interpreter::InterpreterContext context = interpreter::ContextBuilder::CreateInterpreterContext(code_context_, query_funcs_.plan_func);</code></p>
<p>If the LLVM function can not be translated (because of missing features/types) a <code>NotSupportedException</code> is thrown.</p>
<p>The ContextBuilder works in 4 steps:</p>
<ol type="1">
<li>Analysis</li>
<li>Register Allocation</li>
<li>Translation</li>
<li>Finalization</li>
</ol>
<p>Internal the ContextBuilder assigns indexes to LLVM values and instructions, which are usually only accessed by raw pointers. They are used to access those in a continuous way, merge several LLVM values and to compute liveliness. Those indexes stay inside the ContextBuilder and do not end up in the InterpreterContext. They are completely independent from the indexes in the InterpreterContext!</p>
<h4 id="analysis">1. Analysis</h4>
<p>Analysis the LLVM function and creates additional information, but doesn't create bytecode.</p>
<ul>
<li>Determining liveliness of all LLVM values (definition and last usage)
<ul>
<li>Linear scan algorithm using reverse post order traversal of basic blocks</li>
<li>The scheduling of the basic blocks is determined by the reverse post order traversal to make this work</li>
</ul></li>
<li>Merges LLVM values that are equivalent, e.g. when LLVM instructions translate to NOPs</li>
<li>Merges LLVM constants, which have the same value</li>
</ul>
<h4 id="register-allocation">2. Register Allocation</h4>
<p>Global register allocation: maps every LLVM Value in the LLVM function to a value slot (register).For now, only the naive register allocation is available: every LLVM Value is assigned to a unique value slot (SSA characteristic)</p>
<h4 id="translation">3. Translation</h4>
<p>Translates every LLVM instruction into a bytecode instruction (if not NOP) and places it in the bytecode stream.</p>
<p>As the translation is done in one pass and the instructions can have different size, the destination instruction index for branch instructions is not known when creating the instruction. Therefore these relocations are saved and applied at the end of the pass, when all indexes are known.</p>
<p>At the end of each basic block, mov instructions are created to resolve the Phi's referencing the basic block.</p>
<p>Because of the Phi swap problem (lost copy) it can happen, that during translation additional value slots are needed that have not been mapped by the register allocation. The number of additional temporary value slots is tracked and added to the overall number of value slots during finalization.</p>
<h4 id="finalization">4. Finalization</h4>
<p>Calculate overall number of required value slots (including the temporary ones added in the translation pass) and prepare the data structures in the interpreter context for creating the activation record.</p>
<h3 id="interpreterqueryinterpreter">interpreter::QueryInterpreter</h3>
<p>Takes a interpreter context and executes the function it was created for by interpreting the bytecode.</p>
<p><code>return_value = interpreter::QueryInterpreter::ExecuteFunction(context, {args, ...});</code></p>
<p>For every invocation of a function, a new activation record is created, so recursive calls are actually possible.</p>
<h2 id="testing-plan">Testing Plan</h2>
<p>Unit tests are still missing. Most methods in the interpreter are hard to test, as they require a lot of context. Planned are tests that test the interpreter as a whole with small LLVM functions that cover edge cases e.g. for PHI handling.</p>
<h2 id="trade-offs-and-potential-problems">Trade-offs and Potential Problems</h2>
<ul>
<li>Not complete LLVM IR instruction coverage</li>
<li>LLVM vector types are not supported</li>
<li>LLVM values are restricted to max. 8 byte</li>
</ul>
<p><em>But</em> every query except OrderBy that is currently created by our test cases is supported.</p>
<h2 id="future-work">Future Work</h2>
<ul>
<li>Add register allocation with Linear Scan</li>
</ul>
</body>
</html>
